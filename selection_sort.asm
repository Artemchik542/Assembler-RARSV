	li x12, 4 # нужная константа
	li x13, 0 # адресс массива
	li x28, 0 # номер элемента в массиве
	li x24, 0 # счетчик 1
	li x25, 0 # счетчик 2
	
	li x17, 5 
	ecall
	mv, x11, x10 # кол-во элементов в массиве
	addi x11, x11, -1 # т.к. массив с 0
	li x17, 9 # подготовили массив
	ecall
	mv x13, x10 # адресс массива
	mv x23, x13 # сдвигающийся адрес массива
	li x17, 5
	
read_loop: # запись входящих элементов в массив
	ecall
	sw x10, (x23) # запись в массив
	addi x23, x23, 4 # следующая ячейка памяти
	addi x24, x24, 1 # счетчик
	bge x11, x24, read_loop
	
	mv x23, x13 # вернули нормальный адрес массива
	li x24, 0 # обнулили счетчик
	
main_loop:
	lw x27, (x23) # x27 - здесь должен в итоге быть минимальный элемент из оставшихся не отсортированных
	mv x25, x23 # место в памяти для цикла выбора
	mv x26, x24 # вторичный счетчик для цикла выбора
	
	
choose_loop: # цикл выбора наименьшего элемента
	addi x25, x25, 4
	addi x26, x26, 1 # вторичный счетчик
	lw x10, (x25) # взяли след. элемент в массиве для сравнения
	bge x10, x27, skip
	mv x27, x10 # само минимальное (промежуточное) значение
	mv x28, x25 # ее позиция в памяти
skip:
	blt x26, x11, choose_loop
	lw x10, (x23)
	beq x10, x27, noswapneed # если элементы равны, то пропустить смену
	
	lw x10, (x23) # изьяли "неправильный" элемент, на который указывает главный счетчик
	sw x27, (x23) # положили новый мин. элемен на место первого
	sw x10, (x28) # положили изьятый элемент на место "неправильного"
	
noswapneed:
	addi x23, x23, 4 # главный счетчик места в памяти
	addi x24, x24, 1 # главный счетчик
	
	blt x24, x11, main_loop
	
	mv x23, x13 # вернули нормальный адрес массива
	li x24, 0 # обнулили счетчик
	
write_loop: # вывод элементов из отсортированного массива
	li x17, 1
	lw x10, (x23) # выводим на экран
	ecall
	li x17, 11
	li x10, ' ' # разделение чисел
	ecall
	addi x23, x23, 4
	addi x24, x24, 1 # счетчик
	bge x11, x24, write_loop